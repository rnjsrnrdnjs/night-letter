"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const net_1 = require("net");
const vendors_json_1 = __importDefault(require("./vendors.json")); // from https://macaddress.io/database-download/json
/*

$ arp -a

Interface: 192.168.137.1 --- 0x2
  Internet Address      Physical Address      Type      Vendor
  192.168.137.255       ff-ff-ff-ff-ff-ff     static
  224.0.0.22            01-00-5e-00-00-16     static
  224.0.0.251           01-00-5e-00-00-fb     static
  224.0.0.252           01-00-5e-00-00-fc     static
  239.255.255.250       01-00-5e-7f-ff-fa     static
  255.255.255.255       ff-ff-ff-ff-ff-ff     static

Interface: 192.168.2.2 --- 0x9
  Internet Address      Physical Address      Type      Vendor
  192.168.2.1           04-a1-51-1b-12-92     dynamic
  192.168.2.255         ff-ff-ff-ff-ff-ff     static
  224.0.0.2             01-00-5e-00-00-02     static
  224.0.0.22            01-00-5e-00-00-16     static
  224.0.0.251           01-00-5e-00-00-fb     static
  224.0.0.252           01-00-5e-00-00-fc     static
  239.255.255.250       01-00-5e-7f-ff-fa     static
  255.255.255.255       ff-ff-ff-ff-ff-ff     static

======================================================================

> await getArpTable()

[
  { ip: '192.168.137.255', mac: 'ff-ff-ff-ff-ff-ff', type: 'static', vendor: '' },
  { ip: '224.0.0.22', mac: '01-00-5e-00-00-16', type: 'static', vendor: '' },
  { ip: '224.0.0.251', mac: '01-00-5e-00-00-fb', type: 'static', vendor: '' },
  { ip: '224.0.0.252', mac: '01-00-5e-00-00-fc', type: 'static', vendor: '' },
  { ip: '239.255.255.250', mac: '01-00-5e-7f-ff-fa', type: 'static', vendor: '' },
  { ip: '255.255.255.255', mac: 'ff-ff-ff-ff-ff-ff', type: 'static', vendor: '' },
  { ip: '192.168.2.1', mac: '04-a1-51-1b-12-92', type: 'dynamic', vendor: '' },
  { ip: '192.168.2.255', mac: 'ff-ff-ff-ff-ff-ff', type: 'static', vendor: '' },
  { ip: '224.0.0.2', mac: '01-00-5e-00-00-02', type: 'static', vendor: '' },
  { ip: '224.0.0.22', mac: '01-00-5e-00-00-16', type: 'static', vendor: '' },
  { ip: '224.0.0.251', mac: '01-00-5e-00-00-fb', type: 'static', vendor: '' },
  { ip: '224.0.0.252', mac: '01-00-5e-00-00-fc', type: 'static', vendor: '' },
  { ip: '239.255.255.250', mac: '01-00-5e-7f-ff-fa', type: 'static', vendor: '' },
  { ip: '255.255.255.255', mac: 'ff-ff-ff-ff-ff-ff', type: 'static', vendor: '' }
]

*/
/**
 * Normalizes a MAC address so that `-` is
 * replaced `:` and is converted to lower case
 *
 * Example: `04-A1-51-1B-12-92` => `04:a1:51:1b:12:92`
 * @param mac The MAC Address to normalize
 */
function normalize(mac) {
    return mac.replace(/\-/g, ':').toLowerCase();
}
/**
 * Fixes the non compliant MAC addresses returned on Apple systems by adding a leading 0 on parts of the address
 * @param mac The MAC address to FIX
 */
function fixMAC(mac) {
    return normalize(mac)
        .split(':')
        .map(part => (part.length === 1 ? '0' + part : part))
        .join(':');
}
/**
 * Checks if a MAC address is valid
 * @param mac The MAC address to validate
 */
function isMAC(mac) {
    return /^([0-9A-F]{2}[:-]){5}([0-9A-F]{2})$/i.test(mac);
}
exports.isMAC = isMAC;
/**
 * Checks if a MAC address prefix is valid
 * @param prefix The prefix to validate
 */
function isPrefix(prefix) {
    return /^([0-9A-F]{2}[:-]){2}([0-9A-F]{2})$/i.test(prefix);
}
exports.isPrefix = isPrefix;
/**
 * Retrieves the networks' arp table
 */
function getTable() {
    return new Promise((resolve, reject) => {
        // Get the Address Resolution Protocol cache
        child_process_1.exec('arp -a', (err, rawArpData) => {
            if (err) {
                // If there was an error then simply reject
                reject(err);
                return;
            }
            /*
              Split the table into rows
      
              Expected output:
      
              Interface: 192.168.137.1 --- 0x2
                  Internet Address      Physical Address      Type      Vendor
                  192.168.1.255         ff-ff-ff-ff-ff-ff     static
                  192.168.2.1           04-a1-51-1b-12-92     dynamic
                  224.0.0.22            01-00-5e-00-00-16     static
            */
            const rows = rawArpData.split('\n');
            /**
             * The arp table
             */
            const table = [];
            // Loop over each row
            for (const row of rows) {
                let ip;
                let mac;
                let type;
                if (process.platform.substring(0, 3) === 'win') {
                    // Parse the rows as they are returned on Windows systems
                    // Trim the white space from the row and collapse double spaces then
                    // split the row into columns of ip, mac, type
                    ;
                    [ip, mac, type] = row
                        .trim()
                        .replace(/\s+/g, ' ')
                        .split(' ');
                }
                else {
                    // Parse the rows as they are returned on unix (Mac or Linux) systems
                    const match = /.*\((.*?)\) at (.{0,17}) (?:\[ether\]|on)/g.exec(row);
                    if (match && match.length === 3) {
                        ip = match[1];
                        mac = fixMAC(match[2]);
                        type = 'unknown';
                    }
                    else {
                        continue;
                    }
                }
                /*
                  If `ip` isn't a valid IP address or `mac` isn't
                  a valid MAC address then this is a header
                  row (e.g. "Interface: 192.168.137.1 --- 0x2")
                  so we can just ignore it.
                */
                if (!net_1.isIP(ip) || !isMAC(mac))
                    continue;
                const nomalizedMac = normalize(mac);
                const vendor = vendors_json_1.default.find(({ id }) => nomalizedMac.startsWith(id.toLowerCase()));
                // Add this row to the table
                table.push({
                    ip,
                    mac: nomalizedMac,
                    type,
                    vendor: vendor ? vendor.cn : ''
                });
            }
            // Resolve with the populated arp table
            resolve(table);
        });
    });
}
exports.getTable = getTable;
/**
 * Gets the MAC address for the given `ip` address
 * @param ip The IP address
 */
function toMAC(ip) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!net_1.isIP(ip))
            throw Error('Invalid IP');
        // Get the arp table
        const arpTable = yield getTable();
        // Try to find a match in the table
        const match = arpTable.find(row => row.ip === ip);
        // If no match was found then return null
        if (!match)
            return null;
        // Otherwise return with the mac
        return match.mac;
    });
}
exports.toMAC = toMAC;
/**
 * Gets the IP address for given `mac` address
 * @param mac The MAC address
 */
function toIP(mac) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!isMAC(mac))
            throw Error('Invalid MAC');
        mac = normalize(mac);
        // Get the arp table
        const arpTable = yield getTable();
        // Try to find a match in the table
        const match = arpTable.find(row => row.mac === mac);
        // If no match was found then return null
        if (!match)
            return null;
        // Otherwise return with the ip
        return match.ip;
    });
}
exports.toIP = toIP;
/**
 * Returns all devices on the network with
 * the specified MAC prefix
 * @param prefix the prefix to search for
 */
function fromPrefix(prefix) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!isPrefix(prefix))
            throw Error('Invalid Prefix');
        const table = yield getTable();
        return table.filter(row => row.mac.startsWith(prefix));
    });
}
exports.fromPrefix = fromPrefix;
function is(type, address) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!net_1.isIP(address) && !isMAC(address))
            throw Error('Invalid address');
        if (process.platform === 'darwin' && ['static', 'dynamic'].includes(type)) {
            throw Error('Function not available on Mac architecture');
        }
        if (isMAC(address))
            address = normalize(address);
        const arpTable = yield getTable();
        let actualType = 'undefined';
        for (const row of arpTable) {
            if (row.ip === address || row.mac === address) {
                actualType = row.type;
                break;
            }
        }
        return actualType === type;
    });
}
exports.is = is;
exports.default = {
    fromPrefix,
    getTable,
    is,
    isIP: net_1.isIP,
    isMAC,
    isPrefix,
    toIP,
    toMAC
};
